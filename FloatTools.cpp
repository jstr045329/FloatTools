//----------------------------------------------------------------------------------------------------------------------
//                                                    Float Tools 
//----------------------------------------------------------------------------------------------------------------------
#include <stdlib.h>
#include <complex>
#include <cmath>

namespace FloatTools {

    //------------------------------------------------------------------------------------------------------------------
    //                                             Approximate Equality
    //
    // If you've ever tested two floats for equality, you know that x == y will give you an undesirable answer in
    // situations like this:
    //
    //      if (1 == 0.9999999999) {
    //          doStuff();
    //      }
    //
    // Therefore, we define some tolerance tol (which defaults to 1E-9 if not passed in) and check if the difference
    // between the two numbers is less than that. Note that if you pass in a negative value for tol, this function will
    // always return false.
    //
    //------------------------------------------------------------------------------------------------------------------
    bool approx_equal(double x1, double x2, double tol) {
        return (std::abs(x1 - x2) < tol);
    }

    bool approx_equal(double x1, double x2) {
        return approx_equal(x1, x2, 1E-9);
    }

    // tol is applied independently to real and imaginary parts
    bool approx_equal(std::complex<double> x1, std::complex<double> x2, double tol) {
        return (approx_equal(x1.real(), x2.real(), tol) && approx_equal(x1.imag(), x2.imag(), tol));
    }

    bool approx_equal(std::complex<double> x1, std::complex<double> x2) {
        return approx_equal(x1, x2, 1E-9);
    }

    //------------------------------------------------------------------------------------------------------------------
    //                                             Random Floating Point
    //
    // This function takes the random bits generated by rand() and reinterprets those random bits as a float. As a
    // result you get the full dynamic range of float. This function is also division free, which means you do not have
    // to check for division by zero, division by almost zero, etc. This function allows subnormal numbers and -0.
    //
    //------------------------------------------------------------------------------------------------------------------
    float rand_float() {
        long x;
        int exponent_bits = 0x7f800000;
        do {
            x = rand();
        } while ((x & exponent_bits) == exponent_bits);
        float *y = (float*) &x;
        return *y;
    }

    double rand_double() {
        unsigned long x1, x2, x3;
        unsigned long exponent_bits = 0x7ff0000000000000;
        do {
            x1 = (((unsigned long) rand()) << 32) & 0xffffffff00000000;
            x2 = (unsigned long) rand();
            x3 = x1 + x2;
        } while ((x3 & exponent_bits) == exponent_bits);
        double *y = (double*) &x3;
        return *y;
    }


    // Magnitude squared of complex number:
    float mag_squared(std::complex<float> x) {
        return (x.real() * x.real() + x.imag() * x.imag());
    }

    float one_magnitude(std::complex<float> x) {
        return std::sqrt(mag_squared(x));
    }

    double db_up_from(double x_linear, double db_up) {
        double x_db = 10.0 * log10(x_linear);
        double y_db = x_db + db_up;
        return pow(10.0, 0.1 * y_db);
    }
}
